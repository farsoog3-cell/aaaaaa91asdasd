<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Molfa Embroidery â€” ØµÙˆØ±Ø© Ø¥Ù„Ù‰ ØºØ±Ø² (Ø­ÙˆØ§Ù Ø¯Ù‚ÙŠÙ‚Ø©)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body{font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:#f3f4f6; color:#111;}
  .mono{font-family:ui-monospace, Menlo, Monaco, "Roboto Mono", monospace;}
  .svg-wrap { width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
  .svg-wrap svg, .svg-wrap object { width:100%; height:100%; }
  header h1{ font-size:1.1rem; }
</style>
</head>
<body class="min-h-screen flex flex-col">
<header class="bg-indigo-700 text-white py-4 shadow text-center">
  <h1 class="text-xl md:text-2xl font-semibold">Molfa â€” ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ Ù…Ø®Ø·Ø· ØºØ±Ø² (Ø­ÙˆØ§Ù Ø¯Ù‚ÙŠÙ‚Ø©)</h1>
  <p class="text-sm">Sobel edge detection â†’ ØªØ±ØªÙŠØ¨ Ù…Ø³Ø§Ø±Ø§Øª â†’ ØªØ¨Ø³ÙŠØ· â†’ ØªØµØ¯ÙŠØ± SVG/PNG/DST/DTE/DSE</p>
</header>

<main class="container mx-auto p-4 md:p-6 flex-grow">
  <div class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4">
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
      <div class="space-y-3">
        <label class="block font-medium">Ø§Ø®ØªØ± ØµÙˆØ±Ø©</label>
        <input id="file" type="file" accept="image/*" class="w-full p-2 border rounded"/>
        <div class="mt-3">
          <label class="text-sm block mb-1">Ø¹ØªØ¨Ø© Ø§Ù„Ø­Ø§ÙØ© (0-255)</label>
          <input id="threshold" type="range" min="10" max="255" value="120" class="w-full"/>
          <div class="text-xs text-gray-500 mt-1">Ø¹Ø¯Ù„ Ù„ØªÙ‚Ù„ÙŠÙ„/Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ù†Ù‚Ø§Ø· Ø§Ù„Ø­Ø§ÙØ©</div>
        </div>
        <div class="mt-3">
          <label class="text-sm block mb-1">ØªØ¨Ø³ÙŠØ· Ø§Ù„Ù…Ø³Ø§Ø± (epsilon px)</label>
          <input id="epsilon" type="number" min="0" max="10" step="0.5" value="1.0" class="w-full p-2 border rounded"/>
        </div>
        <div class="mt-3">
          <label class="text-sm block mb-1">Ù…Ù‚ÙŠØ§Ø³ Ø§Ù„ØªØµØ¯ÙŠØ± (px â†’ 0.1mm)</label>
          <input id="exportScale" type="number" value="0.2" step="0.1" min="0.05" max="5" class="w-full p-2 border rounded"/>
          <div class="text-xs text-gray-500 mt-1">Ù…Ø«Ø§Ù„: 0.2 ÙŠØ¹Ù†ÙŠ 1px = 0.02cm (0.1mm ÙˆØ­Ø¯Ø©)</div>
        </div>

        <div class="mt-3 flex flex-col sm:flex-row gap-3">
          <button id="process" class="flex-1 bg-indigo-600 text-white py-2 rounded hover:bg-indigo-700">ğŸ”§ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØºØ±Ø² ÙˆÙ…Ù„ÙØ§Øª</button>
        </div>

        <div class="mt-3 flex flex-col sm:flex-row gap-3">
          <button id="downloadSvg" class="flex-1 bg-blue-600 text-white py-2 rounded hidden">â¬‡ï¸ SVG</button>
          <button id="downloadDst" class="flex-1 bg-green-600 text-white py-2 rounded hidden">â¬‡ï¸ DST</button>
          <button id="downloadDte" class="flex-1 bg-pink-600 text-white py-2 rounded hidden">â¬‡ï¸ DTE</button>
          <button id="downloadDse" class="flex-1 bg-orange-600 text-white py-2 rounded hidden">â¬‡ï¸ DSE</button>
          <button id="downloadPng" class="flex-1 bg-gray-700 text-white py-2 rounded hidden">â¬‡ï¸ PNG</button>
        </div>
      </div>

      <div class="md:col-span-2 space-y-3">
        <div class="bg-gray-50 p-3 rounded min-h-[360px] flex items-center justify-center">
          <div id="svgPreview" class="svg-wrap w-full h-full text-gray-500">Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ø¨Ø¹Ø¯</div>
        </div>
        <pre id="log" class="mono text-xs h-40 overflow-auto whitespace-pre-wrap bg-white p-2 rounded border"></pre>
      </div>
    </div>
  </div>
</main>

<script>
function log(msg){ const el=document.getElementById('log'); el.textContent += '['+new Date().toLocaleTimeString()+'] '+msg+"\n"; el.scrollTop = el.scrollHeight; }
function forceDownload(blob, name){ const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url;a.download=name;document.body.appendChild(a);a.click();a.remove();setTimeout(()=>URL.revokeObjectURL(url),2000); }

function makeWorkerFromFunc(fn){ const src = fn.toString(); const blob=new Blob(['('+src+')()'],{type:'application/javascript'}); return new Worker(URL.createObjectURL(blob)); }

/* Worker: ÙŠÙ‚ÙˆÙ… Ø¨ Soble -> ØªØ¬Ù…ÙŠØ¹ Ù…ÙƒÙˆÙ†Ø§Øª -> ØªØ±ØªÙŠØ¨ Ù†Ù‚Ø§Ø· -> ØªØ¨Ø³ÙŠØ· -> Ø¨Ù†Ø§Ø¡ Ù…Ù„ÙØ§Øª */
const worker = makeWorkerFromFunc(function(){
  // ØªØ¨Ø³ÙŠØ· Ø®Ø·ÙŠ: Ramerâ€“Douglasâ€“Peucker
  function simplifyDP(points, epsilon){
    if(points.length < 3) return points.slice();
    const sqr = (a)=>a*a;
    function perpDist(pt, a, b){
      const dx = b[0]-a[0], dy = b[1]-a[1];
      if(dx===0 && dy===0) return Math.hypot(pt[0]-a[0], pt[1]-a[1]);
      const t = ((pt[0]-a[0])*dx + (pt[1]-a[1])*dy) / (dx*dx+dy*dy);
      const projx = a[0] + t*dx, projy = a[1] + t*dy;
      return Math.hypot(pt[0]-projx, pt[1]-projy);
    }
    function rdp(pts, eps){
      let dmax=0, index=-1;
      for(let i=1;i<pts.length-1;i++){
        const d = perpDist(pts[i], pts[0], pts[pts.length-1]);
        if(d > dmax){ index = i; dmax = d; }
      }
      if(dmax > eps){
        const left = rdp(pts.slice(0,index+1), eps);
        const right = rdp(pts.slice(index), eps);
        return left.slice(0,left.length-1).concat(right);
      }
      return [pts[0], pts[pts.length-1]];
    }
    return rdp(points, epsilon);
  }

  // Sobel operator -> Ù†Ù‚Ø§Ø· Ø­Ø§ÙØ© (x,y)
  function sobelPoints(imageData, w, h, thresh){
    const gray = new Uint8ClampedArray(w*h);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i=(y*w+x)*4;
        gray[y*w+x] = Math.round((imageData[i]+imageData[i+1]+imageData[i+2])/3);
      }
    }
    const gx = [-1,0,1,-2,0,2,-1,0,1];
    const gy = [-1,-2,-1,0,0,0,1,2,1];
    const out = new Uint8Array(w*h);
    const pts = [];
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        let sx=0, sy=0;
        let k = 0;
        for(let ky=-1; ky<=1; ky++){
          for(let kx=-1; kx<=1; kx++,k++){
            const val = gray[(y+ky)*w + (x+kx)];
            sx += gx[k]*val; sy += gy[k]*val;
          }
        }
        const mag = Math.hypot(sx,sy);
        if(mag > thresh){
          out[y*w+x] = 1;
          pts.push([x,y]);
        }
      }
    }
    return {map: out, pts};
  }

  // Ø§Ø¬Ù…Ø¹ Ù…ÙƒÙˆÙ†Ø§Øª Ù…ØªØµÙ„Ø© (4-conn)
  function collectComponents(map, w, h){
    const visited = new Uint8Array(w*h);
    const comps = [];
    for(let i=0;i<w*h;i++){
      if(map[i] && !visited[i]){
        const stack=[i]; visited[i]=1; const comp=[];
        while(stack.length){
          const idx=stack.pop();
          const y = Math.floor(idx/w), x = idx - y*w;
          comp.push([x,y]);
          const nbs = [idx-1, idx+1, idx-w, idx+w];
          for(const nb of nbs){
            if(nb>=0 && nb<w*h && map[nb] && !visited[nb]){
              visited[nb]=1; stack.push(nb);
            }
          }
        }
        comps.push(comp);
      }
    }
    return comps;
  }

  // ØªØ±ØªÙŠØ¨ Ù†Ù‚Ø§Ø· Ù…ÙƒÙˆÙ‘Ù† Ø¹Ø¨Ø± Ù†Ù‡Ø¬ Ø£Ù‚Ø±Ø¨ Ø¬Ø§Ø± Ù„ØªÙƒÙˆÙŠÙ† Ø®Ø· Ù…ØªØµÙ„ (Ø¨Ø³ÙŠØ·)
  function orderNearest(points){
    if(points.length<=2) return points.slice();
    const pts = points.slice();
    const ordered = [pts.shift()];
    while(pts.length){
      const last = ordered[ordered.length-1];
      let bestIdx = 0, bestD = Infinity;
      for(let i=0;i<pts.length;i++){
        const d = (last[0]-pts[i][0])**2 + (last[1]-pts[i][1])**2;
        if(d < bestD){ bestD = d; bestIdx = i; }
      }
      ordered.push(pts.splice(bestIdx,1)[0]);
    }
    return ordered;
  }

  function buildExportArray(points, exportScale, label){
    const header = new Uint8Array(512);
    const name = ('LA:'+label+'\n').slice(0,80);
    for(let i=0;i<name.length;i++) header[i] = name.charCodeAt(i);
    const body = [];
    let prevx = 0, prevy = 0;
    function toCoord(px){ return Math.round(px * exportScale); }
    for(const p of points){
      const x = toCoord(p[0]), y = toCoord(p[1]);
      let dx = x - prevx, dy = y - prevy;
      while(Math.abs(dx) > 127 || Math.abs(dy) > 127){
        const sx = Math.max(-127, Math.min(127, dx));
        const sy = Math.max(-127, Math.min(127, dy));
        body.push(sx & 0xFF, sy & 0xFF, 0x03);
        dx -= sx; dy -= sy; prevx += sx; prevy += sy;
      }
      body.push(dx & 0xFF, dy & 0xFF, 0x03);
      prevx = x; prevy = y;
    }
    body.push(0x00,0x00,0xF3);
    const arr = new Uint8Array(512 + body.length);
    arr.set(header,0); arr.set(new Uint8Array(body),512);
    return arr;
  }

  onmessage = async (ev) => {
    const { dataURL, threshold, epsilon, exportScale } = ev.data;
    try{
      const blob = await (await fetch(dataURL)).blob();
      const img = await createImageBitmap(blob);
      const w = 800; // Ù†Ø³ØªØ®Ø¯Ù… Ø¹Ø±Ø¶ Ø£Ø¹Ù„Ù‰ Ù„Ø¯Ù‚Ø© Ø£ÙØ¶Ù„
      const h = Math.round(img.height * (w / img.width));
      const off = new OffscreenCanvas(w,h);
      const ctx = off.getContext('2d');
      ctx.drawImage(img,0,0,w,h);
      const id = ctx.getImageData(0,0,w,h);

      // Sobel -> Ø®Ø±ÙŠØ·Ø© + Ù†Ù‚Ø§Ø·
      const {map, pts} = sobelPoints(id.data, w, h, threshold|0);
      logWorker('Ù†Ù‚Ø§Ø· Ø­Ø§ÙØ© Ø£ÙˆÙ„ÙŠØ©: ' + pts.length);

      // ØªØ¬Ù…ÙŠØ¹ Ù…ÙƒÙˆÙ†Ø§Øª Ù…ØªØµÙ„Ø©
      const comps = collectComponents(map, w, h);
      logWorker('Ù…ÙƒÙˆÙ†Ø§Øª Ù…ØªØµÙ„Ø©: ' + comps.length);

      // Ù†Ø¸Ù… ÙƒÙ„ Ù…ÙƒÙˆÙ‘Ù† Ø¥Ù„Ù‰ Ù…Ø³Ø§Ø± Ù…Ø±ØªØ¨ ÙˆØ¨Ø³Ù‘Ø·Ù‡
      const orderedPaths = [];
      for(const comp of comps){
        // ØªØ±ØªÙŠØ¨ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙƒÙˆÙ‘Ù†
        const ord = orderNearest(comp);
        const simp = simplifyDP(ord, Number(epsilon) || 1.0);
        if(simp.length >= 2) orderedPaths.push(simp);
      }
      logWorker('Ù…Ø³Ø§Ø±Ø§Øª Ø¨Ø¹Ø¯ Ø§Ù„ØªØ±ØªÙŠØ¨ ÙˆØ§Ù„ØªØ¨Ø³ÙŠØ·: ' + orderedPaths.length);
      // Ø¯Ù…Ø¬ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„ÙƒØ¨ÙŠØ±Ø© Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ù†Ù‚Ø§Ø· ÙˆØ§Ø­Ø¯Ø© (Ø­ÙØ¸ ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª)
      const merged = [];
      for(const p of orderedPaths){
        // Ø¥Ø°Ø§ Ø£Ø±Ø¯Ù†Ø§ ÙØ§ØµÙ„ Ù‚ÙØ²: Ù†Ø¶Ø¹ Ø¹Ù„Ø§Ù…Ø© Ø¨Ø¯Ø§ÙŠØ© (we'll encode jump by separate point with flag)
        for(const pt of p) merged.push([pt[0], pt[1], 0]); // flag 0 = stitch
        // Ø¨Ø¹Ø¯ ÙƒÙ„ Ù…ÙƒÙˆÙ‘Ù† Ù†Ø¶Ø¹ Ù†Ù‚Ø·Ø© ØµØºÙŠØ±Ø© ÙƒÙ‚ÙØ²Ø© â€” Ù„ÙƒÙ† ÙÙŠ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø¨Ø³ÙŠØ·Ø© Ø³Ù†ÙƒØªÙÙŠ Ø¨Ø§Ù„Ø¨Ù‚Ø§Ø¡ Ù…ØªØµÙ„Ù‹Ø§
      }
      if(merged.length < 2) merged.push([0,0,0], [20,20,0]);

      // Ù„ØµÙŠØºØ© Ø§Ù„ØªØµÙˆÙŠØ± ÙÙŠ SVG: Ù†Ø­ØªØ§Ø¬ ÙÙ‚Ø· Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
      const polyPoints = merged.map(p => [p[0], p[1]]);
      // Ø¨Ù†Ø§Ø¡ Ù…Ù„ÙØ§Øª DST/DTE/DSE (Ù†Ø³ØªØ®Ø¯Ù… Ù†ÙØ³ Ø§Ù„ØªØ´ÙÙŠØ± Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠ)
      const dstArr = buildExportArray(polyPoints, Number(exportScale) || 0.2, 'MOLFA_DST');
      const dteArr = buildExportArray(polyPoints, Number(exportScale) || 0.2, 'MOLFA_DTE');
      const dseArr = buildExportArray(polyPoints, Number(exportScale) || 0.2, 'MOLFA_DSE');

      // Ø¨Ù†Ø§Ø¡ SVG: Ø§Ù„ØµÙˆØ±Ø© + Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ø³ÙˆØ¯ + Ù†Ù‚Ø§Ø· Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©/Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
      let svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${w}' height='${h}' viewBox='0 0 ${w} ${h}'>`;
      svg += `<image href='${dataURL}' x='0' y='0' width='${w}' height='${h}' preserveAspectRatio='xMidYMid slice'/>`;
      // Ù†Ø±Ø³Ù… ÙƒÙ„ Ù…Ø³Ø§Ø± Ù…Ù†ÙØµÙ„ (Ø¬ÙˆÙ‡Ø± Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©)
      svg += `<g stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none">`;
      for(const path of orderedPaths){
        svg += `<polyline points="${path.map(pt=>pt[0]+','+pt[1]).join(' ')}" />`;
      }
      svg += `</g>`;
      // Ù†Ù‚Ø§Ø· Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙˆØ§Ù„Ù†Ù‡Ø§ÙŠØ© (Ù†Ø£Ø®Ø° Ø£ÙˆÙ„ ÙˆØ£Ø®Ø± Ù†Ù‚Ø·Ø© Ù…Ù† merged)
      const first = polyPoints[0], last = polyPoints[polyPoints.length-1];
      svg += `<circle cx="${first[0]}" cy="${first[1]}" r="4" fill="green" />`;
      svg += `<circle cx="${last[0]}" cy="${last[1]}" r="4" fill="blue" />`;
      svg += `</svg>`;

      // Ù†ÙˆÙ„Ø¯ PNG Ù…Ù† OffscreenCanvas
      const pngBlob = await off.convertToBlob({type:'image/png', quality:0.92});

      // Ø£Ø±Ø³Ù„ Ø§Ù„Ù†ØªÙŠØ¬Ø©ØŒ Ù†Ù†Ù‚Ù„ Ø§Ù„Ù€ArrayBuffers Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡
      postMessage({ svg, dst: dstArr.buffer, dte: dteArr.buffer, dse: dseArr.buffer, png: pngBlob, notes: {paths: orderedPaths.length, points: polyPoints.length} }, [dstArr.buffer, dteArr.buffer, dseArr.buffer]);
    }catch(err){
      postMessage({ error: err && err.message ? err.message : String(err) });
    }
  };

  // Ù„Ø§ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… console Ø¯Ø§Ø®Ù„ worker ÙÙŠ Ø¨Ø¹Ø¶ Ø§Ù„Ø¨ÙŠØ¦Ø§Øª Ù„Ø°Ø§ Ù†Ø­Ø§ÙˆÙ„ Ø¥Ø±Ø³Ø§Ù„ Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  function logWorker(m){
    try{ postMessage({type:'log', msg: m}); }catch(e){}
  }
});

const fileInput = document.getElementById('file');
const btn = document.getElementById('process');
const svgPreview = document.getElementById('svgPreview');
const dlSvg = document.getElementById('downloadSvg');
const dlDst = document.getElementById('downloadDst');
const dlDte = document.getElementById('downloadDte');
const dlDse = document.getElementById('downloadDse');
const dlPng = document.getElementById('downloadPng');
const thresholdInput = document.getElementById('threshold');
const epsilonInput = document.getElementById('epsilon');
const exportScaleInput = document.getElementById('exportScale');

let lastSvg, lastDst, lastDte, lastDse, lastPng;

worker.onmessage = (ev) => {
  const data = ev.data;
  if(data && data.type === 'log'){ log('[worker] '+data.msg); return; }
  if(data.error){ log('Ø®Ø·Ø£ Ù…Ù† Ø§Ù„Ø¹Ø§Ù…Ù„: ' + data.error); return; }
  log('ØªÙ…Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© â€” Ù…Ø³Ø§Ø±Ø§Øª: ' + (data.notes && data.notes.paths) + ', Ù†Ù‚Ø§Ø·: ' + (data.notes && data.notes.points));
  lastSvg = new Blob([data.svg], {type:'image/svg+xml'});
  lastDst = new Blob([data.dst], {type:'application/octet-stream'});
  lastDte = new Blob([data.dte], {type:'application/octet-stream'});
  lastDse = new Blob([data.dse], {type:'application/octet-stream'});
  lastPng = data.png;

  const url = URL.createObjectURL(lastSvg);
  svgPreview.innerHTML = `<object type="image/svg+xml" data="${url}" style="width:100%;height:100%"></object>`;

  dlSvg.classList.remove('hidden');
  dlDst.classList.remove('hidden');
  dlDte.classList.remove('hidden');
  dlDse.classList.remove('hidden');
  dlPng.classList.remove('hidden');

  dlSvg.onclick = ()=> forceDownload(lastSvg, 'molfa_stitch.svg');
  dlDst.onclick = ()=> forceDownload(lastDst, 'molfa_stitch.dst');
  dlDte.onclick = ()=> forceDownload(lastDte, 'molfa_stitch.dte');
  dlDse.onclick = ()=> forceDownload(lastDse, 'molfa_stitch.dse');
  dlPng.onclick = ()=> forceDownload(lastPng, 'molfa_preview.png');
};

btn.addEventListener('click', async ()=>{
  const f = fileInput.files[0];
  if(!f){ alert('Ø§Ø®ØªØ± ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹'); return; }
  const reader = new FileReader();
  reader.onload = ()=> {
    const dataURL = reader.result;
    log('Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„Ø¹Ø§Ù…Ù„. ØªØ­Ø±ÙŠÙƒ...');
    worker.postMessage({
      dataURL,
      threshold: Number(thresholdInput.value||120),
      epsilon: Number(epsilonInput.value||1.0),
      exportScale: Number(exportScaleInput.value||0.2)
    });
  };
  reader.readAsDataURL(f);
});
</script>
</body>
</html>
