<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Molfa — تحويل الصورة إلى طرز (Cross-Stitch)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body{font-family:Inter,system-ui,Arial; background:#f3f4f6; color:#111;}
  .mono{font-family:ui-monospace,monospace;}
  .svg-wrap{width:100%;height:100%;display:flex;align-items:center;justify-content:center;}
  .svg-wrap svg,.svg-wrap object{width:100%;height:100%;}
  header p{font-size:0.9rem; opacity:0.9;}
</style>
</head>
<body class="min-h-screen flex flex-col">
<header class="bg-indigo-700 text-white py-4 shadow text-center">
  <h1 class="text-xl font-semibold">Molfa — صورة → طرز (Cross-Stitch) — تصدير SVG/PNG/DST/DTE/DSE</h1>
  <p>الناتج: معاينة بالصورة + غرزة X ملونة فوق كل خانة. ملفات التصدير تحتوي الغرز فقط (لماكينات التطريز).</p>
</header>

<main class="container mx-auto p-4 md:p-6 flex-grow">
  <div class="bg-white rounded-xl shadow p-4 md:p-6">
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
      <div>
        <label class="block font-medium">اختر صورة</label>
        <input id="file" type="file" accept="image/*" class="w-full p-2 border rounded"/>
        
        <div class="mt-3">
          <label class="text-sm block mb-1">حجم الخلية (px) — cell size</label>
          <input id="cellSize" type="number" min="4" max="32" value="8" class="w-full p-2 border rounded"/>
          <div class="text-xs text-gray-500 mt-1">كل خانة ستُطرَز بصليب (X). قيمة أصغر → طراز أدق.</div>
        </div>

        <div class="mt-3">
          <label class="text-sm block mb-1">عدد ألوان الخيط (k)</label>
          <input id="kcolors" type="number" min="1" max="12" value="6" class="w-full p-2 border rounded"/>
          <div class="text-xs text-gray-500 mt-1">كم مجموعة ألوان ستُستخدم لتقليل الألوان (K-means).</div>
        </div>

        <div class="mt-3">
          <label class="text-sm block mb-1">طول الغرزة (px)</label>
          <input id="stitchStep" type="number" min="1" max="16" value="4" class="w-full p-2 border rounded"/>
          <div class="text-xs text-gray-500 mt-1">المسافة بين نقاط على الخط أثناء بناء كل ضلع من الـX.</div>
        </div>

        <div class="mt-3">
          <label class="text-sm block mb-1">مقياس التصدير (px → 0.1mm)</label>
          <input id="exportScale" type="number" value="0.2" step="0.05" min="0.05" max="5" class="w-full p-2 border rounded"/>
          <div class="text-xs text-gray-500 mt-1">مثال: 0.2 يناسب غالباً.</div>
        </div>

        <div class="mt-4 flex gap-2">
          <button id="process" class="flex-1 bg-indigo-600 text-white py-2 rounded">🔧 توليد طرز وتصدير</button>
        </div>

        <div class="mt-3 grid grid-cols-2 gap-2">
          <button id="downloadSvg" class="hidden bg-blue-600 text-white py-2 rounded">⬇️ SVG</button>
          <button id="downloadDst" class="hidden bg-green-600 text-white py-2 rounded">⬇️ DST</button>
          <button id="downloadDte" class="hidden bg-pink-600 text-white py-2 rounded">⬇️ DTE</button>
          <button id="downloadDse" class="hidden bg-yellow-600 text-white py-2 rounded">⬇️ DSE</button>
          <button id="downloadPng" class="hidden bg-gray-700 text-white py-2 rounded">⬇️ PNG</button>
        </div>
      </div>

      <div class="md:col-span-2">
        <div class="bg-gray-50 p-3 rounded min-h-[380px] flex items-center justify-center">
          <div id="svgPreview" class="svg-wrap text-gray-500">لم يتم التوليد بعد</div>
        </div>
        <pre id="log" class="mono text-xs h-40 overflow-auto whitespace-pre-wrap bg-white p-2 rounded border mt-3"></pre>
      </div>
    </div>
  </div>
</main>

<script>
function log(msg){ const el=document.getElementById('log'); el.textContent += '['+new Date().toLocaleTimeString()+'] '+msg + "\\n"; el.scrollTop = el.scrollHeight; }
function forceDownload(blob,name){ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),2000); }

function makeWorkerFromFunc(fn){ const src = fn.toString(); const blob=new Blob(['('+src+')()'],{type:'application/javascript'}); return new Worker(URL.createObjectURL(blob)); }

/* Worker: quantize colors, build cross-stitch X shape per cell, produce ordered stitch points, export bytes */
const worker = makeWorkerFromFunc(function(){
  // simple K-means color quantization
  function quantize(samples, k, iter=6){
    if(samples.length === 0) return [];
    k = Math.max(1, Math.min(k, samples.length));
    const centers = [];
    for(let i=0;i<k;i++) centers.push(samples[Math.floor(Math.random()*samples.length)].slice());
    for(let it=0; it<iter; it++){
      const sums = Array.from({length:k}, ()=>[0,0,0,0]);
      for(const s of samples){
        let best=0, bd=Infinity;
        for(let j=0;j<k;j++){
          const c = centers[j];
          const d = (s[0]-c[0])**2 + (s[1]-c[1])**2 + (s[2]-c[2])**2;
          if(d<bd){ bd=d; best=j; }
        }
        sums[best][0]+=s[0]; sums[best][1]+=s[1]; sums[best][2]+=s[2]; sums[best][3]+=1;
      }
      for(let j=0;j<k;j++){
        if(sums[j][3]>0){
          centers[j][0] = Math.round(sums[j][0]/sums[j][3]);
          centers[j][1] = Math.round(sums[j][1]/sums[j][3]);
          centers[j][2] = Math.round(sums[j][2]/sums[j][3]);
        }
      }
    }
    return centers;
  }

  // nearest color index
  function nearestIndex(c, centers){
    let best=0, bd=Infinity;
    for(let i=0;i<centers.length;i++){
      const cc = centers[i];
      const d = (c[0]-cc[0])**2 + (c[1]-cc[1])**2 + (c[2]-cc[2])**2;
      if(d<bd){ bd=d; best=i; }
    }
    return best;
  }

  // Build Tajima-like DST bytes
  function buildDstBytes(points, exportScale, label){
    const header = new Uint8Array(512);
    const name = ('LA:'+label+'\n').slice(0,80);
    for(let i=0;i<name.length;i++) header[i] = name.charCodeAt(i);
    const body = [];
    let prevx=0, prevy=0;
    function coord(px){ return Math.round(px * exportScale); }
    for(const pt of points){
      const x = coord(pt[0]), y = coord(pt[1]);
      let dx = x - prevx, dy = y - prevy;
      // split large moves
      while(Math.abs(dx) > 127 || Math.abs(dy) > 127){
        const sx = Math.max(-127, Math.min(127, dx));
        const sy = Math.max(-127, Math.min(127, dy));
        body.push((sx & 0xFF), (sy & 0xFF), 0x01); // 0x01 treat as jump marker
        dx -= sx; dy -= sy; prevx += sx; prevy += sy;
      }
      body.push((dx & 0xFF), (dy & 0xFF), 0x03); // 0x03 normal stitch
      prevx = x; prevy = y;
    }
    body.push(0x00,0x00,0xF3);
    const arr = new Uint8Array(512 + body.length);
    arr.set(header,0); arr.set(new Uint8Array(body),512);
    return arr;
  }

  onmessage = async (ev) => {
    const { dataURL, cellSize, kcolors, stitchStep, exportScale } = ev.data;
    try{
      const img = await createImageBitmap(await (await fetch(dataURL)).blob());
      // Determine work size based on desired cell size and keep aspect ratio; width chosen to keep whole cells
      const cell = Math.max(4, Math.min(32, Number(cellSize) || 8));
      const gridW = Math.floor(img.width / cell) || 1;
      const gridH = Math.floor(img.height / cell) || 1;
      const w = gridW * cell;
      const h = gridH * cell;

      // draw original at working size on OffscreenCanvas
      const off = new OffscreenCanvas(w,h);
      const ctx = off.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);
      const id = ctx.getImageData(0,0,w,h);
      const d = id.data;

      // sample cell average colors
      const samples = [];
      const cellColors = new Array(gridH);
      for(let gy=0; gy<gridH; gy++){
        cellColors[gy] = new Array(gridW);
        for(let gx=0; gx<gridW; gx++){
          let sr=0, sg=0, sb=0, cnt=0;
          for(let yy=gy*cell; yy<(gy+1)*cell; yy++){
            for(let xx=gx*cell; xx<(gx+1)*cell; xx++){
              const i = (yy*w + xx)*4;
              sr += d[i]; sg += d[i+1]; sb += d[i+2]; cnt++;
            }
          }
          const ar = Math.round(sr/cnt), ag = Math.round(sg/cnt), ab = Math.round(sb/cnt);
          samples.push([ar,ag,ab]);
          cellColors[gy][gx] = [ar,ag,ab];
        }
      }

      // quantize palette
      const k = Math.max(1, Math.min(12, Number(kcolors) || 6));
      const palette = quantize(samples, k, 8);
      if(palette.length === 0) palette.push([0,0,0]);

      // Build cross-stitch X shapes for each cell: two diagonals crossing center
      // We'll create stitch points along each diagonal with spacing = stitchStep
      const step = Math.max(1, Math.min(16, Number(stitchStep) || 4));
      const stitchPoints = []; // list of {x,y,colorIndex}
      for(let gy=0; gy<gridH; gy++){
        for(let gx=0; gx<gridW; gx++){
          const col = cellColors[gy][gx];
          const ci = nearestIndex(col, palette);
          // center and corners
          const x0 = gx*cell, y0 = gy*cell;
          const x1 = x0 + cell, y1 = y0 + cell;
          // diagonal 1: (x0,y0) -> (x1,y1)
          const dx = x1 - x0, dy = y1 - y0;
          const l = Math.hypot(dx,dy);
          const nsteps = Math.max(1, Math.ceil(l/step));
          for(let s=0;s<=nsteps;s++){
            const t = s/nsteps;
            const xx = x0 + dx*t;
            const yy = y0 + dy*t;
            stitchPoints.push([xx,yy,ci]);
          }
          // diagonal 2: (x1,y0) -> (x0,y1)
          const dx2 = x0 - x1, dy2 = y1 - y0;
          const l2 = Math.hypot(dx2,dy2);
          const nsteps2 = Math.max(1, Math.ceil(l2/step));
          for(let s=0;s<=nsteps2;s++){
            const t = s/nsteps2;
            const xx = x1 + dx2*t;
            const yy = y0 + dy2*t;
            stitchPoints.push([xx,yy,ci]);
          }
        }
      }

      // For DST we need a single ordered list of points; naive approach: row-major order already reasonable
      // We'll compress consecutive duplicate points
      const merged = [];
      for(const p of stitchPoints){
        if(merged.length === 0) merged.push(p);
        else {
          const last = merged[merged.length-1];
          if(Math.hypot(last[0]-p[0], last[1]-p[1]) >= 0.5) merged.push(p);
        }
      }

      // Build DST/DTE/DSE arrays (coordinates in px * exportScale)
      // For machine files we do not include color info (machines expect color-change commands separately),
      // but points are ordered — color info could be exported as separate color-run metadata if needed.
      const dstArr = buildDstBytes(merged, Number(exportScale) || 0.2, 'MOLFA_DST');
      const dteArr = buildDstBytes(merged, Number(exportScale) || 0.2, 'MOLFA_DTE');
      const dseArr = buildDstBytes(merged, Number(exportScale) || 0.2, 'MOLFA_DSE');

      // Build SVG: image background + colored X stitches overlay (one polyline per diagonal pair or small strokes)
      // We'll draw small short line segments with stroke matching palette color
      let svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${w}' height='${h}' viewBox='0 0 ${w} ${h}'>`;
      svg += `<image href='${dataURL}' x='0' y='0' width='${w}' height='${h}' preserveAspectRatio='xMidYMid slice'/>`;
      // draw each X as two colored lines (slightly thicker to show thread)
      svg += `<g stroke-linecap="round" stroke-linejoin="round">`;
      // iterate grid again to draw two lines for each cell with palette color
      for(let gy=0; gy<gridH; gy++){
        for(let gx=0; gx<gridW; gx++){
          const ci = nearestIndex(cellColors[gy][gx], palette);
          const col = palette[ci];
          const colorStr = `rgb(${col[0]},${col[1]},${col[2]})`;
          const x0 = gx*cell + 1, y0 = gy*cell + 1; // inset a bit so stitches look nicer
          const x1 = x0 + cell - 2, y1 = y0 + cell - 2;
          svg += `<line x1="${x0}" y1="${y0}" x2="${x1}" y2="${y1}" stroke="${colorStr}" stroke-width="${Math.max(1, Math.round(cell/6))}" />`;
          svg += `<line x1="${x1}" y1="${y0}" x2="${x0}" y2="${y1}" stroke="${colorStr}" stroke-width="${Math.max(1, Math.round(cell/6))}" />`;
        }
      }
      svg += `</g>`;
      svg += `</svg>`;

      // Build PNG: draw image then draw colored X lines on canvas
      const ctx2 = off.getContext('2d');
      // redraw original image to ensure background present
      ctx2.clearRect(0,0,w,h);
      const imgBitmap = await createImageBitmap(await (await fetch(dataURL)).blob());
      ctx2.drawImage(imgBitmap, 0, 0, w, h);
      for(let gy=0; gy<gridH; gy++){
        for(let gx=0; gx<gridW; gx++){
          const ci = nearestIndex(cellColors[gy][gx], palette);
          const col = palette[ci];
          ctx2.strokeStyle = `rgb(${col[0]},${col[1]},${col[2]})`;
          ctx2.lineWidth = Math.max(1, Math.round(cell/6));
          const x0 = gx*cell + 1, y0 = gy*cell + 1;
          const x1 = x0 + cell - 2, y1 = y0 + cell - 2;
          ctx2.beginPath();
          ctx2.moveTo(x0,y0); ctx2.lineTo(x1,y1); ctx2.stroke();
          ctx2.beginPath();
          ctx2.moveTo(x1,y0); ctx2.lineTo(x0,y1); ctx2.stroke();
        }
      }
      const png = await off.convertToBlob({type:'image/png', quality:0.9});

      postMessage({ svg, dst: dstArr.buffer, dte: dteArr.buffer, dse: dseArr.buffer, png, notes: {cells: gridW*gridH, points: merged.length, palette: palette.length} }, [dstArr.buffer, dteArr.buffer, dseArr.buffer]);
    }catch(err){
      postMessage({ error: (err && err.message) ? err.message : String(err) });
    }
  };
});

const fileInput = document.getElementById('file');
const btn = document.getElementById('process');
const preview = document.getElementById('svgPreview');
const dlSvg = document.getElementById('downloadSvg');
const dlDst = document.getElementById('downloadDst');
const dlDte = document.getElementById('downloadDte');
const dlDse = document.getElementById('downloadDse');
const dlPng = document.getElementById('downloadPng');
const cellSizeInput = document.getElementById('cellSize');
const kcolorsInput = document.getElementById('kcolors');
const stitchStepInput = document.getElementById('stitchStep');
const exportScaleInput = document.getElementById('exportScale');

let lastSvg, lastDst, lastDte, lastDse, lastPng;

worker.onmessage = (ev) => {
  if(ev.data && ev.data.type === 'log'){ log('[worker] ' + ev.data.msg); return; }
  if(ev.data.error){ log('خطأ: '+ev.data.error); return; }
  log('تمت المعالجة — خلايا: ' + (ev.data.notes && ev.data.notes.cells) + ', نقاط: ' + (ev.data.notes && ev.data.notes.points) + ', ألوان: ' + (ev.data.notes && ev.data.notes.palette));
  lastSvg = new Blob([ev.data.svg], {type:'image/svg+xml'});
  lastDst = new Blob([ev.data.dst], {type:'application/octet-stream'});
  lastDte = new Blob([ev.data.dte], {type:'application/octet-stream'});
  lastDse = new Blob([ev.data.dse], {type:'application/octet-stream'});
  lastPng = ev.data.png;

  const url = URL.createObjectURL(lastSvg);
  preview.innerHTML = `<object type="image/svg+xml" data="${url}" style="width:100%;height:100%"></object>`;

  dlSvg.classList.remove('hidden');
  dlDst.classList.remove('hidden');
  dlDte.classList.remove('hidden');
  dlDse.classList.remove('hidden');
  dlPng.classList.remove('hidden');

  dlSvg.onclick = ()=> forceDownload(lastSvg, 'molfa_cross_stitch.svg');
  dlDst.onclick = ()=> forceDownload(lastDst, 'molfa_cross_stitch.dst');
  dlDte.onclick = ()=> forceDownload(lastDte, 'molfa_cross_stitch.dte');
  dlDse.onclick = ()=> forceDownload(lastDse, 'molfa_cross_stitch.dse');
  dlPng.onclick = ()=> forceDownload(lastPng, 'molfa_cross_stitch.png');
};

btn.addEventListener('click', () => {
  const f = fileInput.files[0];
  if(!f){ alert('اختر صورة'); return; }
  const reader = new FileReader();
  reader.onload = () => {
    worker.postMessage({
      dataURL: reader.result,
      cellSize: Number(cellSizeInput.value||8),
      kcolors: Number(kcolorsInput.value||6),
      stitchStep: Number(stitchStepInput.value||4),
      exportScale: Number(exportScaleInput.value||0.2)
    });
    log('إرسال الصورة للعامل للمعالجة...');
  };
  reader.readAsDataURL(f);
});
</script>
</body>
</html>
