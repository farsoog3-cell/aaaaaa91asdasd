<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Molfa Embroidery — صورة إلى غرز (حواف دقيقة)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body{font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:#f3f4f6; color:#111;}
  .mono{font-family:ui-monospace, Menlo, Monaco, "Roboto Mono", monospace;}
  .svg-wrap { width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
  .svg-wrap svg, .svg-wrap object { width:100%; height:100%; }
  header h1{ font-size:1.1rem; }
</style>
</head>
<body class="min-h-screen flex flex-col">
<header class="bg-indigo-700 text-white py-4 shadow text-center">
  <h1 class="text-xl md:text-2xl font-semibold">Molfa — تحويل الصورة إلى مخطط غرز (حواف دقيقة)</h1>
  <p class="text-sm">Sobel edge detection → ترتيب مسارات → تبسيط → تصدير SVG/PNG/DST/DTE/DSE</p>
</header>

<main class="container mx-auto p-4 md:p-6 flex-grow">
  <div class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4">
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
      <div class="space-y-3">
        <label class="block font-medium">اختر صورة</label>
        <input id="file" type="file" accept="image/*" class="w-full p-2 border rounded"/>
        <div class="mt-3">
          <label class="text-sm block mb-1">عتبة الحافة (0-255)</label>
          <input id="threshold" type="range" min="10" max="255" value="120" class="w-full"/>
          <div class="text-xs text-gray-500 mt-1">عدل لتقليل/زيادة عدد نقاط الحافة</div>
        </div>
        <div class="mt-3">
          <label class="text-sm block mb-1">تبسيط المسار (epsilon px)</label>
          <input id="epsilon" type="number" min="0" max="10" step="0.5" value="1.0" class="w-full p-2 border rounded"/>
        </div>
        <div class="mt-3">
          <label class="text-sm block mb-1">مقياس التصدير (px → 0.1mm)</label>
          <input id="exportScale" type="number" value="0.2" step="0.1" min="0.05" max="5" class="w-full p-2 border rounded"/>
          <div class="text-xs text-gray-500 mt-1">مثال: 0.2 يعني 1px = 0.02cm (0.1mm وحدة)</div>
        </div>

        <div class="mt-3 flex flex-col sm:flex-row gap-3">
          <button id="process" class="flex-1 bg-indigo-600 text-white py-2 rounded hover:bg-indigo-700">🔧 توليد الغرز وملفات</button>
        </div>

        <div class="mt-3 flex flex-col sm:flex-row gap-3">
          <button id="downloadSvg" class="flex-1 bg-blue-600 text-white py-2 rounded hidden">⬇️ SVG</button>
          <button id="downloadDst" class="flex-1 bg-green-600 text-white py-2 rounded hidden">⬇️ DST</button>
          <button id="downloadDte" class="flex-1 bg-pink-600 text-white py-2 rounded hidden">⬇️ DTE</button>
          <button id="downloadDse" class="flex-1 bg-orange-600 text-white py-2 rounded hidden">⬇️ DSE</button>
          <button id="downloadPng" class="flex-1 bg-gray-700 text-white py-2 rounded hidden">⬇️ PNG</button>
        </div>
      </div>

      <div class="md:col-span-2 space-y-3">
        <div class="bg-gray-50 p-3 rounded min-h-[360px] flex items-center justify-center">
          <div id="svgPreview" class="svg-wrap w-full h-full text-gray-500">لم يتم التوليد بعد</div>
        </div>
        <pre id="log" class="mono text-xs h-40 overflow-auto whitespace-pre-wrap bg-white p-2 rounded border"></pre>
      </div>
    </div>
  </div>
</main>

<script>
function log(msg){ const el=document.getElementById('log'); el.textContent += '['+new Date().toLocaleTimeString()+'] '+msg+"\n"; el.scrollTop = el.scrollHeight; }
function forceDownload(blob, name){ const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url;a.download=name;document.body.appendChild(a);a.click();a.remove();setTimeout(()=>URL.revokeObjectURL(url),2000); }

function makeWorkerFromFunc(fn){ const src = fn.toString(); const blob=new Blob(['('+src+')()'],{type:'application/javascript'}); return new Worker(URL.createObjectURL(blob)); }

/* Worker: يقوم ب Soble -> تجميع مكونات -> ترتيب نقاط -> تبسيط -> بناء ملفات */
const worker = makeWorkerFromFunc(function(){
  // تبسيط خطي: Ramer–Douglas–Peucker
  function simplifyDP(points, epsilon){
    if(points.length < 3) return points.slice();
    const sqr = (a)=>a*a;
    function perpDist(pt, a, b){
      const dx = b[0]-a[0], dy = b[1]-a[1];
      if(dx===0 && dy===0) return Math.hypot(pt[0]-a[0], pt[1]-a[1]);
      const t = ((pt[0]-a[0])*dx + (pt[1]-a[1])*dy) / (dx*dx+dy*dy);
      const projx = a[0] + t*dx, projy = a[1] + t*dy;
      return Math.hypot(pt[0]-projx, pt[1]-projy);
    }
    function rdp(pts, eps){
      let dmax=0, index=-1;
      for(let i=1;i<pts.length-1;i++){
        const d = perpDist(pts[i], pts[0], pts[pts.length-1]);
        if(d > dmax){ index = i; dmax = d; }
      }
      if(dmax > eps){
        const left = rdp(pts.slice(0,index+1), eps);
        const right = rdp(pts.slice(index), eps);
        return left.slice(0,left.length-1).concat(right);
      }
      return [pts[0], pts[pts.length-1]];
    }
    return rdp(points, epsilon);
  }

  // Sobel operator -> نقاط حافة (x,y)
  function sobelPoints(imageData, w, h, thresh){
    const gray = new Uint8ClampedArray(w*h);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i=(y*w+x)*4;
        gray[y*w+x] = Math.round((imageData[i]+imageData[i+1]+imageData[i+2])/3);
      }
    }
    const gx = [-1,0,1,-2,0,2,-1,0,1];
    const gy = [-1,-2,-1,0,0,0,1,2,1];
    const out = new Uint8Array(w*h);
    const pts = [];
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        let sx=0, sy=0;
        let k = 0;
        for(let ky=-1; ky<=1; ky++){
          for(let kx=-1; kx<=1; kx++,k++){
            const val = gray[(y+ky)*w + (x+kx)];
            sx += gx[k]*val; sy += gy[k]*val;
          }
        }
        const mag = Math.hypot(sx,sy);
        if(mag > thresh){
          out[y*w+x] = 1;
          pts.push([x,y]);
        }
      }
    }
    return {map: out, pts};
  }

  // اجمع مكونات متصلة (4-conn)
  function collectComponents(map, w, h){
    const visited = new Uint8Array(w*h);
    const comps = [];
    for(let i=0;i<w*h;i++){
      if(map[i] && !visited[i]){
        const stack=[i]; visited[i]=1; const comp=[];
        while(stack.length){
          const idx=stack.pop();
          const y = Math.floor(idx/w), x = idx - y*w;
          comp.push([x,y]);
          const nbs = [idx-1, idx+1, idx-w, idx+w];
          for(const nb of nbs){
            if(nb>=0 && nb<w*h && map[nb] && !visited[nb]){
              visited[nb]=1; stack.push(nb);
            }
          }
        }
        comps.push(comp);
      }
    }
    return comps;
  }

  // ترتيب نقاط مكوّن عبر نهج أقرب جار لتكوين خط متصل (بسيط)
  function orderNearest(points){
    if(points.length<=2) return points.slice();
    const pts = points.slice();
    const ordered = [pts.shift()];
    while(pts.length){
      const last = ordered[ordered.length-1];
      let bestIdx = 0, bestD = Infinity;
      for(let i=0;i<pts.length;i++){
        const d = (last[0]-pts[i][0])**2 + (last[1]-pts[i][1])**2;
        if(d < bestD){ bestD = d; bestIdx = i; }
      }
      ordered.push(pts.splice(bestIdx,1)[0]);
    }
    return ordered;
  }

  function buildExportArray(points, exportScale, label){
    const header = new Uint8Array(512);
    const name = ('LA:'+label+'\n').slice(0,80);
    for(let i=0;i<name.length;i++) header[i] = name.charCodeAt(i);
    const body = [];
    let prevx = 0, prevy = 0;
    function toCoord(px){ return Math.round(px * exportScale); }
    for(const p of points){
      const x = toCoord(p[0]), y = toCoord(p[1]);
      let dx = x - prevx, dy = y - prevy;
      while(Math.abs(dx) > 127 || Math.abs(dy) > 127){
        const sx = Math.max(-127, Math.min(127, dx));
        const sy = Math.max(-127, Math.min(127, dy));
        body.push(sx & 0xFF, sy & 0xFF, 0x03);
        dx -= sx; dy -= sy; prevx += sx; prevy += sy;
      }
      body.push(dx & 0xFF, dy & 0xFF, 0x03);
      prevx = x; prevy = y;
    }
    body.push(0x00,0x00,0xF3);
    const arr = new Uint8Array(512 + body.length);
    arr.set(header,0); arr.set(new Uint8Array(body),512);
    return arr;
  }

  onmessage = async (ev) => {
    const { dataURL, threshold, epsilon, exportScale } = ev.data;
    try{
      const blob = await (await fetch(dataURL)).blob();
      const img = await createImageBitmap(blob);
      const w = 800; // نستخدم عرض أعلى لدقة أفضل
      const h = Math.round(img.height * (w / img.width));
      const off = new OffscreenCanvas(w,h);
      const ctx = off.getContext('2d');
      ctx.drawImage(img,0,0,w,h);
      const id = ctx.getImageData(0,0,w,h);

      // Sobel -> خريطة + نقاط
      const {map, pts} = sobelPoints(id.data, w, h, threshold|0);
      logWorker('نقاط حافة أولية: ' + pts.length);

      // تجميع مكونات متصلة
      const comps = collectComponents(map, w, h);
      logWorker('مكونات متصلة: ' + comps.length);

      // نظم كل مكوّن إلى مسار مرتب وبسّطه
      const orderedPaths = [];
      for(const comp of comps){
        // ترتيب نقاط المكوّن
        const ord = orderNearest(comp);
        const simp = simplifyDP(ord, Number(epsilon) || 1.0);
        if(simp.length >= 2) orderedPaths.push(simp);
      }
      logWorker('مسارات بعد الترتيب والتبسيط: ' + orderedPaths.length);
      // دمج المسارات الكبيرة إلى قائمة نقاط واحدة (حفظ ترتيب المسارات)
      const merged = [];
      for(const p of orderedPaths){
        // إذا أردنا فاصل قفز: نضع علامة بداية (we'll encode jump by separate point with flag)
        for(const pt of p) merged.push([pt[0], pt[1], 0]); // flag 0 = stitch
        // بعد كل مكوّن نضع نقطة صغيرة كقفزة — لكن في البنية البسيطة سنكتفي بالبقاء متصلًا
      }
      if(merged.length < 2) merged.push([0,0,0], [20,20,0]);

      // لصيغة التصوير في SVG: نحتاج فقط إحداثيات ثنائية الأبعاد
      const polyPoints = merged.map(p => [p[0], p[1]]);
      // بناء ملفات DST/DTE/DSE (نستخدم نفس التشفير التجريبي)
      const dstArr = buildExportArray(polyPoints, Number(exportScale) || 0.2, 'MOLFA_DST');
      const dteArr = buildExportArray(polyPoints, Number(exportScale) || 0.2, 'MOLFA_DTE');
      const dseArr = buildExportArray(polyPoints, Number(exportScale) || 0.2, 'MOLFA_DSE');

      // بناء SVG: الصورة + المسار الأسود + نقاط البداية/النهاية
      let svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${w}' height='${h}' viewBox='0 0 ${w} ${h}'>`;
      svg += `<image href='${dataURL}' x='0' y='0' width='${w}' height='${h}' preserveAspectRatio='xMidYMid slice'/>`;
      // نرسم كل مسار منفصل (جوهر الاحترافية)
      svg += `<g stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none">`;
      for(const path of orderedPaths){
        svg += `<polyline points="${path.map(pt=>pt[0]+','+pt[1]).join(' ')}" />`;
      }
      svg += `</g>`;
      // نقاط البداية والنهاية (نأخذ أول وأخر نقطة من merged)
      const first = polyPoints[0], last = polyPoints[polyPoints.length-1];
      svg += `<circle cx="${first[0]}" cy="${first[1]}" r="4" fill="green" />`;
      svg += `<circle cx="${last[0]}" cy="${last[1]}" r="4" fill="blue" />`;
      svg += `</svg>`;

      // نولد PNG من OffscreenCanvas
      const pngBlob = await off.convertToBlob({type:'image/png', quality:0.92});

      // أرسل النتيجة، ننقل الـArrayBuffers لتحسين الأداء
      postMessage({ svg, dst: dstArr.buffer, dte: dteArr.buffer, dse: dseArr.buffer, png: pngBlob, notes: {paths: orderedPaths.length, points: polyPoints.length} }, [dstArr.buffer, dteArr.buffer, dseArr.buffer]);
    }catch(err){
      postMessage({ error: err && err.message ? err.message : String(err) });
    }
  };

  // لايمكن استخدام console داخل worker في بعض البيئات لذا نحاول إرسال لواجهة المستخدم
  function logWorker(m){
    try{ postMessage({type:'log', msg: m}); }catch(e){}
  }
});

const fileInput = document.getElementById('file');
const btn = document.getElementById('process');
const svgPreview = document.getElementById('svgPreview');
const dlSvg = document.getElementById('downloadSvg');
const dlDst = document.getElementById('downloadDst');
const dlDte = document.getElementById('downloadDte');
const dlDse = document.getElementById('downloadDse');
const dlPng = document.getElementById('downloadPng');
const thresholdInput = document.getElementById('threshold');
const epsilonInput = document.getElementById('epsilon');
const exportScaleInput = document.getElementById('exportScale');

let lastSvg, lastDst, lastDte, lastDse, lastPng;

worker.onmessage = (ev) => {
  const data = ev.data;
  if(data && data.type === 'log'){ log('[worker] '+data.msg); return; }
  if(data.error){ log('خطأ من العامل: ' + data.error); return; }
  log('تمت المعالجة — مسارات: ' + (data.notes && data.notes.paths) + ', نقاط: ' + (data.notes && data.notes.points));
  lastSvg = new Blob([data.svg], {type:'image/svg+xml'});
  lastDst = new Blob([data.dst], {type:'application/octet-stream'});
  lastDte = new Blob([data.dte], {type:'application/octet-stream'});
  lastDse = new Blob([data.dse], {type:'application/octet-stream'});
  lastPng = data.png;

  const url = URL.createObjectURL(lastSvg);
  svgPreview.innerHTML = `<object type="image/svg+xml" data="${url}" style="width:100%;height:100%"></object>`;

  dlSvg.classList.remove('hidden');
  dlDst.classList.remove('hidden');
  dlDte.classList.remove('hidden');
  dlDse.classList.remove('hidden');
  dlPng.classList.remove('hidden');

  dlSvg.onclick = ()=> forceDownload(lastSvg, 'molfa_stitch.svg');
  dlDst.onclick = ()=> forceDownload(lastDst, 'molfa_stitch.dst');
  dlDte.onclick = ()=> forceDownload(lastDte, 'molfa_stitch.dte');
  dlDse.onclick = ()=> forceDownload(lastDse, 'molfa_stitch.dse');
  dlPng.onclick = ()=> forceDownload(lastPng, 'molfa_preview.png');
};

btn.addEventListener('click', async ()=>{
  const f = fileInput.files[0];
  if(!f){ alert('اختر صورة أولاً'); return; }
  const reader = new FileReader();
  reader.onload = ()=> {
    const dataURL = reader.result;
    log('إرسال الصورة للعامل. تحريك...');
    worker.postMessage({
      dataURL,
      threshold: Number(thresholdInput.value||120),
      epsilon: Number(epsilonInput.value||1.0),
      exportScale: Number(exportScaleInput.value||0.2)
    });
  };
  reader.readAsDataURL(f);
});
</script>
</body>
</html>
